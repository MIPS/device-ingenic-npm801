#!/bin/bash
#
# Copyright (c) 2013,2014,2016,2017 Imagination Technologies
# Original-Author: Chris Larsen <chris.larsen@imgtec.com>
#
# Writes Android filesystems to the sd card for Ingenic tablet (NPM801).
# Derived from the CI20 versions of mksdcard and mksdcard-ext scripts.
#
# Usage:
#   ./mksdcard-ext4 /dev/sdX
#

set -e

cleanup()
{
  echo "Cleaning up..."
  [ -z "${sdMount}" ] || sudo umount ${sdMount}
  rm -rf ${tmpDir}
  rm -rf ${verifyDir}
  [ "${finished}" = "true" ] && sudo eject ${device} && echo "Cleanup completed; it is safe to remove your card"
  trap - EXIT INT TERM
}
trap cleanup EXIT INT TERM

die()
{
  echo "$@" >&2
  exit 1
}

sfdisk_npm801()
{
  local sfdisk_tool=`which sfdisk`
  local blockdev_tool=`which blockdev`
  local partprobe_tool=`which partprobe`

  [ -f "$sfdisk_tool" ] || die "No sfdisk in \$PATH"
  [ -f "$blockdev_tool" ] || die "No blockdev in \$PATH"
  [ -f "$partprobe_tool" ] || die "No partprobe in \$PATH"
  [ -b "$1" ] || die "Device '$1' not found"

  sfdisk_version=`$sfdisk_tool --version | sed 's,.*2\.\([0-9]*\)\.[0-9]*,\1,'`

  unset sfdisk_is_ancient
  test $sfdisk_version -lt 26 && sfdisk_is_ancient=1

  sfdisk_dev="$1"
  shift

  sfdisk_parts=`echo $* | tr ' ' '\n'`

  set +e
  if [ $sfdisk_is_ancient ]; then
      echo "$sfdisk_parts" | tr -d M | sudo $sfdisk_tool -L -uM "$sfdisk_dev"
  else
      echo "$sfdisk_parts" | sudo $sfdisk_tool "$sfdisk_dev"
  fi
  set -e

  sudo $blockdev_tool --rereadpt $sfdisk_dev
  sudo $partprobe_tool -d $sfdisk_dev
  sleep 2
}

init_core()
{
  readonly tmpDir=`mktemp -d`
  readonly verifyDir=`mktemp -d`
  readonly ubootPrebuiltDir="$ANDROID_BUILD_TOP/device/ingenic/npm801/u-boot"
  #check for U-Boot prebuilt dir
  [ ! -z "${ANDROID_BUILD_TOP}" ] || die "ANDROID_BUILD_TOP has not been initialized"
  [ -e "${ubootPrebuiltDir}" ] || die "U-Boot prebuilt directory '${ubootPrebuiltDir}' does not exist"

  readonly device="$1"
  # Check device
  [ -e "${device}" ] || die "Device '${device}' not found"

  # Check for awk
  [ -z `which awk 2>&1` ] && die "No 'awk' present"

  # Check for md5sum
  [ -z `which md5sum 2>&1` ] && die "No 'md5sum' present"

  # Check for mkfs.ext4
  [ -z `which mkfs.ext4 2>&1` ] && die "No 'mkfs.ext4' present"

  # Check for mkfs.f2fs
  [ -z `which mkfs.f2fs 2>&1` ] && die "No 'mkfs.f2fs' present"

  # Check if $OUT is defined
  [ -z $OUT ] && die '$OUT is not defined'

  # Check for stat
  [ -z `which stat 2>&1` ] && die "No 'stat' present"

  # Check for umount
  [ -z `which umount 2>&1` ] && die "No 'umount' present"

  # Check for Android images
  readonly bootImg=${BOOTIMG:-${OUT}/boot.img}
  [ -e "${bootImg}" ] || die "Android boot image '${bootImg}' not found"
  readonly recoveryImg=${RECOVERYIMG:-${OUT}/recovery.img}
  [ -e "${recoveryImg}" ] || die "Android recovery image '${recoveryImg}' not found"
  readonly systemImg=${SYSTEMIMG:-${OUT}/system.img}
  [ -e "${systemImg}" ] || die "Android system image '${systemImg}' not found"
  readonly vendorImg=${VENDORIMG:=${OUT}/vendor.img}
  [ -e "${vendorImg}" ] || die "Android vendor image '${vendorImg}' not found"

  readonly dtb=$ANDROID_BUILD_TOP/device/ingenic/npm801/dtb/npm801-sdcard.dtb
  [ -e "${dtb}" ] || die "Kernel device tree blob '${dtb}' not found"

  set +e
  # Unmount the SD card
  echo "Unmounting $1*"
  `sudo umount $1*`
  set -e

  grep ${device} /etc/mtab >/dev/null && \
  die "Device '${device}' contains mounted partitions"

  return 0
}

init_partition_layout_constants()
{
  partitions=("boot" "system" "vendor" "extended" "cache" "userdata")
  readonly partNum=${#partitions[@]}

  # Partition sizes and offsets represent size in MB
  local bootPartSize=30
  local cachePartSize=256
  local dataPartSize=2048
  local vendorPartSize=64
  local extendedPartPadding=1

  local systemImgSize=`stat -c %s ${systemImg}`
  local megabyte=$((1024 * 1024))
  local systemPartSize=$((${systemImgSize} / megabyte))

  local extPartSize=$((2 * ${extendedPartPadding} + ${cachePartSize} + ${dataPartSize}))

  # 2M is skipped and used for storing U-Boot outside the visible partition layout
  local bootPartOffset="2"
  local systemPartOffset=$((${bootPartOffset} + ${bootPartSize}))
  local vendorPartOffset=$((${systemPartOffset} + ${systemPartSize}))
  local extPartOffset=$((${vendorPartOffset} + ${vendorPartSize}))
  local cachePartOffset=$((${extPartOffset} + ${extendedPartPadding}))
  local dataPartOffset=$((${cachePartOffset} + ${cachePartSize} + ${extendedPartPadding}))

  local tmpPartitionLayout="${bootPartOffset}M,${bootPartSize}M,83"
  tmpPartitionLayout="${tmpPartitionLayout} ${systemPartOffset}M,${systemPartSize}M,83"
  tmpPartitionLayout="${tmpPartitionLayout} ${vendorPartOffset}M,${vendorPartSize}M,83"
  tmpPartitionLayout="${tmpPartitionLayout} ${extPartOffset}M,${extPartSize}M,5"
  tmpPartitionLayout="${tmpPartitionLayout} ${cachePartOffset}M,${cachePartSize}M,83"
  tmpPartitionLayout="${tmpPartitionLayout} ${dataPartOffset}M,${dataPartSize}M,83"
  readonly partitionLayout=${tmpPartitionLayout}
}

init_uboot_constants()
{
  readonly bs_uBootImg=1024
  readonly seek_uBootImg=14
}

init_constants()
{
  init_uboot_constants
  init_partition_layout_constants
}

configure_sd_card_partitions()
{
  sfdisk_npm801 ${device} ${partitionLayout}

  for((i=1; i<=${partNum}; i++));
  do
    case ${partitions[$i-1]} in
    "boot")
      readonly partBoot="${device}${i}"
      sudo mkfs.ext4 -L "${partitions[$i-1]}" ${partBoot}
      ;;
    "system")
      readonly partSystem="${device}${i}"
      ;;
    "vendor")
      readonly partVendor="${device}${i}"
      ;;
    "cache")
      readonly partCache="${device}${i}"
      sudo mkfs.f2fs -l "${partitions[$i-1]}" ${partCache}
      ;;
    "userdata")
      readonly partUserdata="${device}${i}"
      sudo mkfs.f2fs -l "${partitions[$i-1]}" ${partUserdata}
      ;;
    esac
  done

  # sdMount is not initialized in init_constants()
  # the way it is used in the cleanup() function
  readonly sdMount=${tmpDir}/sd_mount
  mkdir ${sdMount}
  # mount ext4 partition
  sudo mount ${partBoot} ${sdMount}
  sudo chmod a+w ${sdMount}
}

burn_uboot()
{
  # install MMC u-boot
  # SPL is located on NAND
  sudo dd if=${ubootPrebuiltDir}/u-boot.img of=${device} obs=${bs_uBootImg} seek=${seek_uBootImg}
}

burn_android_images()
{
  # copy Android boot image
  sudo cp -v ${bootImg} ${sdMount}/

  # copy Android recovery image
  sudo cp -v ${recoveryImg} ${sdMount}/

  echo -e "\nPlease wait, writing system.img"
  sudo dd if=${systemImg} of=${partSystem}

  echo -e "\nPlease wait, writing vendor.img"
  sudo dd if=${vendorImg} of=${partVendor}

  # copy kernel device tree blob
  sudo cp -v ${dtb} ${sdMount}/jz4780.dtb
}

verify_burned_segment()
{
  originalChecksum=`md5sum $1 | awk '{print $1}'`
  copiedChecksum=`sudo md5sum $2 | awk '{print $1}'`
  if [ "$originalChecksum" != "$copiedChecksum" ]; then
    die "Burned data mismatch. $1 md5sum does not match md5sum of $2"
  fi
}

verify_burned_sd_card()
{
  sync

  local bs_verify=1
  local ubootImageSize=$(stat -c%s ${ubootPrebuiltDir}/u-boot.img)
  local skip_uBootImg=$((${bs_uBootImg} * ${seek_uBootImg}))
  sudo dd if=${device} of=${verifyDir}/u-boot.img bs=${bs_verify} skip=${skip_uBootImg} count=${ubootImageSize}
  verify_burned_segment ${ubootPrebuiltDir}/u-boot.img ${verifyDir}/u-boot.img

  verify_burned_segment ${bootImg} ${sdMount}/boot.img
  verify_burned_segment ${recoveryImg} ${sdMount}/recovery.img
  verify_burned_segment ${systemImg} ${partSystem}
  verify_burned_segment ${vendorImg} ${partVendor}
  verify_burned_segment ${dtb} ${sdMount}/jz4780.dtb

  echo "Successfully verified SD card content"
}

init_core $1
init_constants

configure_sd_card_partitions

burn_android_images
burn_uboot

verify_burned_sd_card
finished=true
echo
echo "Finished, wait for clean up before removing your card!"
